/*
 * SPDX-FileCopyrightText: 2022-2023 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "esp_log.h"
#include "driver/mcpwm_prelude.h"
#include "driver/gpio.h"
#include "esp_timer.h"

static const char *TAG = "example";

// --- CONFIGURATION ---
#define SERVO_PULSE_GPIO             0        // PWM output pin
#define BUTTON1_PIN                  1        // CW / Record
#define BUTTON2_PIN                  2        // CCW / Playback

#define SERVO_TIMEBASE_RESOLUTION_HZ 1000000  // 1MHz, 1us per tick
#define SERVO_TIMEBASE_PERIOD        20000    // 20000 ticks, 20ms

// Pulse Widths (Microseconds)
#define PULSE_STOP 1500
#define PULSE_CW   2000
#define PULSE_CCW  1000

// Queue handle for inter-task communication
QueueHandle_t servo_queue;

// --- TASK 1: SERVO CONTROL (Consumer) ---
void servo_task(void *pvParameters)
{
    ESP_LOGI(TAG, "Servo Task Starting...");

    // 1. Create timer
    mcpwm_timer_handle_t timer = NULL;
    mcpwm_timer_config_t timer_config = {
        .group_id = 0,
        .clk_src = MCPWM_TIMER_CLK_SRC_DEFAULT,
        .resolution_hz = SERVO_TIMEBASE_RESOLUTION_HZ,
        .period_ticks = SERVO_TIMEBASE_PERIOD,
        .count_mode = MCPWM_TIMER_COUNT_MODE_UP,
    };
    ESP_ERROR_CHECK(mcpwm_new_timer(&timer_config, &timer));

    // 2. Create operator
    mcpwm_oper_handle_t oper = NULL;
    mcpwm_operator_config_t operator_config = {
        .group_id = 0, 
    };
    ESP_ERROR_CHECK(mcpwm_new_operator(&operator_config, &oper));
    ESP_ERROR_CHECK(mcpwm_operator_connect_timer(oper, timer));

    // 3. Create comparator
    mcpwm_cmpr_handle_t comparator = NULL;
    mcpwm_comparator_config_t comparator_config = {
        .flags.update_cmp_on_tez = true,
    };
    ESP_ERROR_CHECK(mcpwm_new_comparator(oper, &comparator_config, &comparator));

    // 4. Create generator
    mcpwm_gen_handle_t generator = NULL;
    mcpwm_generator_config_t generator_config = {
        .gen_gpio_num = SERVO_PULSE_GPIO,
    };
    ESP_ERROR_CHECK(mcpwm_new_generator(oper, &generator_config, &generator));

    // 5. Initial setup
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(generator,
                MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(generator,
                MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, comparator, MCPWM_GEN_ACTION_LOW)));

    ESP_ERROR_CHECK(mcpwm_timer_enable(timer));
    ESP_ERROR_CHECK(mcpwm_timer_start_stop(timer, MCPWM_TIMER_START_NO_STOP));

    // Set initial position to STOP
    ESP_ERROR_CHECK(mcpwm_comparator_set_compare_value(comparator, PULSE_STOP));

    uint32_t received_pulse_width;

    while (1) {
        // Block indefinitely until a new command is received in the queue
        if (xQueueReceive(servo_queue, &received_pulse_width, portMAX_DELAY)) {
            // Update PWM duty cycle
            ESP_ERROR_CHECK(mcpwm_comparator_set_compare_value(comparator, received_pulse_width));
        }
    }
}

// --- TASK 2: BUTTON INPUT (Producer) ---
void button_task(void *pvParameters)
{
    ESP_LOGI(TAG, "Button Task Starting...");

    // Configure GPIOs
    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_INPUT,
        .pin_bit_mask = (1ULL << BUTTON1_PIN) | (1ULL << BUTTON2_PIN),
        .pull_down_en = 0,
        .pull_up_en = 1, // Enable Pull-up
    };
    gpio_config(&io_conf);

    // State Variables
    int prevB1 = 1;
    int prevB2 = 1;
    
    int64_t cw_start_time = 0;
    int64_t cw_duration = 0; // Microseconds
    
    bool reversing = false;
    int64_t reverse_start_time = 0;

    uint32_t current_pulse = PULSE_STOP;
    uint32_t last_sent_pulse = PULSE_STOP;

    while (1) {
        int b1 = gpio_get_level(BUTTON1_PIN);
        int b2 = gpio_get_level(BUTTON2_PIN);
        int64_t now = esp_timer_get_time(); // Time in microseconds

        // --- Logic Implementation ---
        
        if (reversing) {
            current_pulse = PULSE_CCW;
            
            // Check if duration has passed
            if ((now - reverse_start_time) >= cw_duration) {
                reversing = false;
                current_pulse = PULSE_STOP;
                ESP_LOGI(TAG, "Reverse sequence complete.");
            }
        } 
        else {
            // --- BUTTON 1: CW & Record ---
            if (b1 == 0 && prevB1 == 1) {
                cw_start_time = now;
                ESP_LOGI(TAG, "B1 Pressed: CW Start");
            }

            if (b1 == 0) {
                current_pulse = PULSE_CW;
            }

            if (b1 == 1 && prevB1 == 0) {
                cw_duration = now - cw_start_time;
                current_pulse = PULSE_STOP;
                ESP_LOGI(TAG, "B1 Released: Duration %lld us", cw_duration);
            }

            // --- BUTTON 2: Reverse / Playback ---
            if (b2 == 0 && prevB2 == 1 && cw_duration > 0) {
                reversing = true;
                reverse_start_time = now;
                current_pulse = PULSE_CCW;
                ESP_LOGI(TAG, "B2 Pressed: Reversing for %lld us", cw_duration);
            }
        }

        // --- Send Command to Servo Task ---
        // Only send if the state has changed to prevent flooding the queue
        if (current_pulse != last_sent_pulse) {
            xQueueSend(servo_queue, &current_pulse, 0);
            last_sent_pulse = current_pulse;
        }

        // Update edges
        prevB1 = b1;
        prevB2 = b2;

        // Small delay to prevent watchdog starvation and simple debounce
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// --- MAIN ENTRY POINT ---
void app_main(void)
{
    // Create Queue to hold 10 integer commands
    servo_queue = xQueueCreate(10, sizeof(uint32_t));

    // Create Tasks
    xTaskCreate(servo_task, "servo_task", 4096, NULL, 5, NULL);
    xTaskCreate(button_task, "button_task", 4096, NULL, 5, NULL);
}
